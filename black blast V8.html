<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Classic Block Blast (8x8)</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@700&display=swap" rel="stylesheet">

    <style>
        /* --- General Setup & Classic Theme --- */
        :root {
            --background-blue: #3a4a9f;
            --grid-background: #2c3568;
            --text-white: #ffffff;
            --text-gold: #f9d71c;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        html, body {
            height: 100%;
            overflow: hidden;
            font-family: 'Poppins', sans-serif;
            font-weight: 700;
            touch-action: none;
        }

        body {
            background: radial-gradient(circle, #4a5aae 0%, #3a4a9f 100%);
            color: var(--text-white);
            display: flex;
            justify-content: center;
            align-items: center;
            -webkit-user-select: none; /* Safari */
            -ms-user-select: none; /* IE 10+ */
            user-select: none;
        }
        
        #page-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            width: 100%;
            max-width: 420px; /* Controls max size on desktop */
            padding: 10px;
        }
        
        #header {
            width: 100%;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 10px;
        }
        
        #high-score-container, #settings-container {
            font-size: 1.5em;
        }
        #current-score-container {
            font-size: 2.5em;
            display: flex;
            flex-direction: column;
            align-items: center;
            line-height: 1.1;
        }

        .icon {
            color: var(--text-gold);
            vertical-align: middle;
            margin-right: 5px;
        }

        #settings-container {
            cursor: pointer;
        }
        
        #game-container {
            display: flex;
            flex-direction: column;
            gap: 15px;
            align-items: center;
        }
        
        #main-game-area {
            position: relative;
        }

        canvas#game-board {
            display: block;
            background-color: var(--grid-background);
            border: 3px solid #252d4a;
            border-radius: 5px;
        }
        
        #piece-selection-panel {
            display: flex;
            width: 100%;
            justify-content: space-around;
            align-items: center;
        }
        
        .piece-container {
            width: 100px;
            height: 100px;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: grab;
            transition: transform 0.2s ease, opacity 0.3s;
        }

        .piece-container.used {
            opacity: 0.3;
            pointer-events: none;
        }
        
        .piece-container:active {
            cursor: grabbing;
        }

        .piece-canvas {
            max-width: 100%;
            max-height: 100%;
        }

        #combo-indicator {
            font-size: 0.4em;
            color: var(--text-gold);
            letter-spacing: 1px;
            opacity: 0;
            transform: translateY(10px) scale(0.8);
            transition: all 0.2s ease-out;
            height: 0;
            overflow: hidden;
        }
        #combo-indicator.visible {
            opacity: 1;
            transform: translateY(0) scale(1);
            height: auto;
            margin-top: 2px;
        }

        /* --- Animations & Effects --- */
        .line-clear-flash {
            position: absolute;
            background: white;
            opacity: 0;
            pointer-events: none;
            z-index: 5;
        }

        @keyframes flash-animation {
            from { opacity: 0.7; }
            to { opacity: 0; }
        }

        /* --- Modal (Game Over & Settings) --- */
        #game-over-modal, #settings-modal {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background-color: rgba(0,0,0,0.6);
            display: flex;
            justify-content: center;
            align-items: center;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
            z-index: 100;
        }
        
        #game-over-modal.visible, #settings-modal.visible {
            opacity: 1;
            pointer-events: all;
        }
        
        .modal-content {
             position: relative;
             background: radial-gradient(circle, #5a6abf 0%, #4a5aae 100%);
             padding: 30px;
             border-radius: 10px;
             text-align: center;
             width: 80%;
             max-width: 320px;
             box-shadow: 0 5px 25px rgba(0,0,0,0.4);
             border: 2px solid #6b7cd3;
        }

        .modal-content h2 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .modal-content p {
            font-size: 1.2em;
            margin-bottom: 25px;
        }
        
        #close-settings-button {
            position: absolute;
            top: 5px;
            right: 15px;
            font-size: 2.5em;
            font-weight: 300;
            color: var(--text-white);
            cursor: pointer;
            line-height: 1;
            transition: transform 0.2s;
        }

        #close-settings-button:hover {
            transform: scale(1.1);
        }

        .modal-button {
            padding: 12px 25px;
            font-size: 1.1em;
            font-family: 'Poppins', sans-serif;
            font-weight: 700;
            background: var(--text-gold);
            color: #554400;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            text-transform: uppercase;
            box-shadow: 0 4px 0 #c7a718;
            transition: all 0.1s ease;
            margin-top: 15px;
        }

        .modal-button:active {
            transform: translateY(2px);
            box-shadow: 0 2px 0 #c7a718;
        }
        
        @media (max-width: 360px) {
            #high-score-container, #settings-container { font-size: 1.2em; }
            #current-score-container { font-size: 2em; }
        }
    </style>
</head>
<body>
    <div id="page-wrapper">
        <div id="header">
            <div id="high-score-container">
                <span class="icon">üëë</span><span id="high-score-display">0</span>
            </div>
            <div id="current-score-container">
                <div id="score-display">0</div>
                <div id="combo-indicator"></div>
            </div>
            <div id="settings-container">
                <span>‚öôÔ∏è</span>
            </div>
        </div>
        
        <div id="game-container">
            <div id="main-game-area">
                <canvas id="game-board"></canvas>
            </div>
            <div id="piece-selection-panel">
                <div id="piece-cont-0" class="piece-container">
                    <canvas class="piece-canvas"></canvas>
                </div>
                <div id="piece-cont-1" class="piece-container">
                    <canvas class="piece-canvas"></canvas>
                </div>
                <div id="piece-cont-2" class="piece-container">
                    <canvas class="piece-canvas"></canvas>
                </div>
            </div>
        </div>
    </div>

    <div id="game-over-modal">
        <div class="modal-content">
            <h2>GAME OVER</h2>
            <p>Score: <span id="final-score">0</span></p>
            <button id="restart-button" class="modal-button">Play Again</button>
        </div>
    </div>

    <div id="settings-modal">
        <div class="modal-content">
            <span id="close-settings-button">&times;</span>
            <h2>Settings</h2>
            <button id="settings-retry-button" class="modal-button">Retry Game</button>
        </div>
    </div>


<script>
document.addEventListener('DOMContentLoaded', () => {

    // --- Game Constants & State ---
    const GRID_SIZE = 8;
    const BLOCK_SIZE = Math.min(45, Math.floor(Math.min(window.innerWidth, window.innerHeight * 0.7) / GRID_SIZE));
    const pieceContexts = [];
    let board, score = 0, highScore = 0, combo = 0, currentPieces = [], gameOver = false;
    let clearingBlocks = [];
    let clearedLineThisRound = false;
    
    let isDragging = false;
    let draggedPiece = null;
    let pointerPos = { x: 0, y: 0 };

    // --- Element References ---
    const mainCanvas = document.getElementById('game-board');
    const mainCtx = mainCanvas.getContext('2d');
    const scoreElement = document.getElementById('score-display');
    const highScoreElement = document.getElementById('high-score-display');
    const comboIndicator = document.getElementById('combo-indicator');
    
    const gameOverModal = document.getElementById('game-over-modal');
    const finalScoreElement = document.getElementById('final-score');
    const restartButton = document.getElementById('restart-button');
    
    const settingsButton = document.getElementById('settings-container');
    const settingsModal = document.getElementById('settings-modal');
    const settingsRetryButton = document.getElementById('settings-retry-button');
    const closeSettingsButton = document.getElementById('close-settings-button');
    
    const pieceContainers = [
        document.getElementById('piece-cont-0'), document.getElementById('piece-cont-1'), document.getElementById('piece-cont-2')
    ];
    pieceContainers.forEach((cont, i) => {
        pieceContexts[i] = cont.querySelector('canvas').getContext('2d');
    });

    // --- Definitions ---
    const COLORS = {
        yellow: { main: '#fdd835', light: '#fff176', dark: '#f9a825'},
        red:    { main: '#e53935', light: '#ef5350', dark: '#c62828'},
        blue:   { main: '#1e88e5', light: '#42a5f5', dark: '#1565c0'},
        purple: { main: '#8e24aa', light: '#ab47bc', dark: '#6a1b9a'},
        cyan:   { main: '#00acc1', light: '#26c6da', dark: '#00838f'},
        green:  { main: '#43a047', light: '#66bb6a', dark: '#2e7d32'},
        orange: { main: '#fb8c00', light: '#ffa726', dark: '#f57c00'}
    };
    
    const PIECE_DEFINITIONS = [
        // Standard Pieces
        { shape: [[1]], color: COLORS.yellow }, { shape: [[1,1]], color: COLORS.orange }, { shape: [[1],[1]], color: COLORS.orange },
        { shape: [[1,1],[1,1]], color: COLORS.blue }, { shape: [[1,1,1]], color: COLORS.purple}, { shape: [[1],[1],[1]], color: COLORS.purple},
        { shape: [[1,1,1,1]], color: COLORS.cyan }, { shape: [[1],[1],[1],[1]], color: COLORS.cyan }, { shape: [[1,1,1,1,1]], color: COLORS.green },
        { shape: [[1],[1],[1],[1],[1]], color: COLORS.green }, { shape: [[0,1,0],[1,1,1]], color: COLORS.orange }, 
        { shape: [[1,0],[1,1]], color: COLORS.blue }, { shape: [[1,1,1],[1,0,0]], color: COLORS.blue },
        { shape: [[1,1,1],[0,0,1]], color: COLORS.orange}, { shape: [[1,1,1],[1,1,1],[1,1,1]], color: COLORS.green },
        { shape: [[1,1,1],[1,1,1]], color: COLORS.purple }, { shape: [[1,1],[1,1],[1,1]], color: COLORS.purple },
        // S/Z Shapes
        { shape: [[1,1,0],[0,1,1]], color: COLORS.red},
        { shape: [[0,1,1],[1,1,0]], color: COLORS.red},
        // Diagonal Shapes
        { shape: [[1,0],[0,1]], color: COLORS.red }, 
        { shape: [[0,1],[1,0]], color: COLORS.red },
        { shape: [[1,0,0],[0,1,0],[0,0,1]], color: COLORS.red },
        { shape: [[0,0,1],[0,1,0],[1,0,0]], color: COLORS.red },
        // New L-Pentominoes (5-block L shapes)
        { shape: [[1, 1, 1], [1, 0, 0], [1, 0, 0]], color: COLORS.red },
        { shape: [[1, 1, 1], [0, 0, 1], [0, 0, 1]], color: COLORS.red },
        { shape: [[1, 0, 0], [1, 0, 0], [1, 1, 1]], color: COLORS.red },
        { shape: [[0, 0, 1], [0, 0, 1], [1, 1, 1]], color: COLORS.red }
    ];
    
    // --- Audio ---
    let audioCtx; const sounds = {};
    function initAudio() {
        if (audioCtx) return;
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        if (!audioCtx) return;
        const createSound = (freq1, freq2, type, vol, dur) => () => {
            const o = audioCtx.createOscillator(), g = audioCtx.createGain();
            o.connect(g); g.connect(audioCtx.destination);
            o.type = type; g.gain.setValueAtTime(vol, audioCtx.currentTime);
            o.frequency.setValueAtTime(freq1, audioCtx.currentTime);
            if (freq2 !== freq1) o.frequency.exponentialRampToValueAtTime(freq2, audioCtx.currentTime + dur);
            g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + dur);
            o.start(); o.stop(audioCtx.currentTime + dur);
        };
        sounds.place = createSound(100, 100, 'sine', 0.2, 0.2);
        sounds.clear = createSound(440, 880, 'sawtooth', 0.2, 0.15);
        sounds.gameOver = createSound(150, 50, 'square', 0.3, 0.5);
    }
    document.body.addEventListener('pointerdown', initAudio, { once: true });


    // --- Core Game Logic ---
    function resetGame() {
        mainCanvas.width = GRID_SIZE * BLOCK_SIZE; mainCanvas.height = GRID_SIZE * BLOCK_SIZE;
        board = Array.from({ length: GRID_SIZE }, () => Array(GRID_SIZE).fill(null));
        loadHighScore(); score = 0; combo = 0; gameOver = false;
        clearedLineThisRound = false;
        
        pieceContainers.forEach(cont => cont.classList.remove('used'));

        const layout = generateInitialLayout();
        board = layout.board;
        currentPieces = layout.startingPieces;
        
        performInitialClear();
        updateScoreDisplay();
        updateComboDisplay();

        drawPiecesForSelection();
        checkGameOver();
        
        gameOverModal.classList.remove('visible');
    }
    
    // --- Starting Layout Generation ---
    function getRandomColor() {
        const colorKeys = Object.keys(COLORS);
        return COLORS[colorKeys[Math.floor(Math.random() * colorKeys.length)]];
    }
    
    function createSymmetricalLayout() {
        const tempBoard = Array.from({ length: GRID_SIZE }, () => Array(GRID_SIZE).fill(null));
        const midPoint = Math.ceil(GRID_SIZE / 2);
        let holes = 0;

        for(let y = 0; y < GRID_SIZE; y++) {
            for(let x = 0; x < midPoint; x++) {
                if(Math.random() > 0.4 || (GRID_SIZE*GRID_SIZE - holes) < GRID_SIZE * GRID_SIZE * 0.4) { 
                    const color = getRandomColor();
                    tempBoard[y][x] = color;
                    if(GRID_SIZE % 2 === 0 || x !== midPoint - 1) {
                        tempBoard[y][GRID_SIZE - 1 - x] = color;
                    }
                } else {
                    holes += 2;
                }
            }
        }
        return tempBoard;
    }

    function createRandomScatterLayout() {
        const tempBoard = Array.from({ length: GRID_SIZE }, () => Array(GRID_SIZE).fill(null));
        let solutions = [];
        let placedPieces = 0;

        while(placedPieces < 3) {
            const piece = PIECE_DEFINITIONS[Math.floor(Math.random() * PIECE_DEFINITIONS.length)];
            let attempts = 0;
            while (attempts < 50) {
                const randX = Math.floor(Math.random() * (GRID_SIZE - piece.shape[0].length + 1));
                const randY = Math.floor(Math.random() * (GRID_SIZE - piece.shape.length + 1));

                let canPlace = true;
                for(let y=0; y < piece.shape.length; y++) { for(let x=0; x < piece.shape[y].length; x++) { if(piece.shape[y][x] && tempBoard[randY + y][randX + x]) { canPlace = false; break; } } if(!canPlace) break; }

                if(canPlace) {
                    piece.shape.forEach((row, y) => row.forEach((val, x) => { if(val) tempBoard[randY + y][randX + x] = 'reserved'; }));
                    solutions.push(piece);
                    placedPieces++;
                    break;
                }
                attempts++;
            }
            if (attempts >= 50 && placedPieces < 3) {
                solutions = [PIECE_DEFINITIONS[0], PIECE_DEFINITIONS[1], PIECE_DEFINITIONS[3]];
                break;
            }
        }
         
        for (let y = 0; y < GRID_SIZE; y++) {
            for (let x = 0; x < GRID_SIZE; x++) {
                if (tempBoard[y][x] === null && Math.random() > 0.4) {
                     tempBoard[y][x] = getRandomColor();
                } else if (tempBoard[y][x] === 'reserved') {
                    tempBoard[y][x] = null;
                }
            }
        }
        return { board: tempBoard, solutions: solutions };
    }

    function generateInitialLayout() {
        let layout;
        let isPlayable;
        let safetyCounter = 0;
    
        do {
            if (Math.random() < 0.5) {
                const tempBoard = createSymmetricalLayout();
                const pieces = [0,1,2].map(i => ({ ...PIECE_DEFINITIONS[Math.floor(Math.random() * PIECE_DEFINITIONS.length)], id: i, used: false }));
                layout = { board: tempBoard, startingPieces: pieces };
            } else {
                const scatter = createRandomScatterLayout();
                layout = { board: scatter.board, startingPieces: scatter.solutions.map((p, i) => ({ ...p, id: i, used: false })) };
            }
            
            isPlayable = layout.startingPieces.some(piece => isPiecePlayable(piece, layout.board));
    
            safetyCounter++;
            if (safetyCounter > 100) {
                console.warn("Could not generate a playable start state in 100 tries. Forcing a simple start.");
                const emptyBoard = Array.from({ length: GRID_SIZE }, () => Array(GRID_SIZE).fill(null));
                const simplePieces = [
                    PIECE_DEFINITIONS[0], PIECE_DEFINITIONS[1], PIECE_DEFINITIONS[3]
                ].map((p,i) => ({...p, id: i, used: false}));
                layout = { board: emptyBoard, startingPieces: simplePieces };
                isPlayable = true;
            }
    
        } while (!isPlayable);
    
        return layout;
    }

    function performInitialClear() {
        let linesToClear = { rows: [], cols: [] };
        for(let i = 0; i < GRID_SIZE; i++) {
            if (board[i].every(cell => cell)) linesToClear.rows.push(i);
            if (board.every(row => row[i])) linesToClear.cols.push(i);
        }
        let linesClearedCount = linesToClear.rows.length + linesToClear.cols.length;
        if(linesClearedCount > 0) {
            score += linesClearedCount * 10;
            linesToClear.rows.forEach(y => board[y].fill(null));
            linesToClear.cols.forEach(x => board.forEach(row => row[x] = null));
        }
    }

    // --- Scoring & State Helpers ---
    function loadHighScore() {
        highScore = parseInt(localStorage.getItem('classicBlockBlastHighScore')) || 0;
        highScoreElement.textContent = highScore;
    }
    
    function saveHighScore() {
        if(score > (parseInt(localStorage.getItem('classicBlockBlastHighScore')) || 0)) {
            localStorage.setItem('classicBlockBlastHighScore', score);
        }
    }
    
    function updateScoreDisplay() {
        scoreElement.textContent = score;
        if(score > highScore) {
            highScore = score;
            highScoreElement.textContent = highScore;
        }
    }

    function updateComboDisplay() {
        if (combo > 1) { // A streak starts from the 2nd consecutive clear
            const multiplier = Math.min(combo, 8);
            comboIndicator.textContent = `COMBO x${multiplier}`;
            comboIndicator.classList.add('visible');
        } else {
            comboIndicator.classList.remove('visible');
        }
    }
    
    // --- Smart Piece Generation ---
    function generateNewPieces() {
        clearedLineThisRound = false; // Reset for the new round of pieces

        const rowFullness = Array(GRID_SIZE).fill(0);
        const colFullness = Array(GRID_SIZE).fill(0);
        for (let y = 0; y < GRID_SIZE; y++) {
            for (let x = 0; x < GRID_SIZE; x++) {
                if (board[y][x]) {
                    rowFullness[y]++;
                    colFullness[x]++;
                }
            }
        }

        const COMBO_HELP_THRESHOLD = 4;
        const targetRows = new Set();
        const targetCols = new Set();
        rowFullness.forEach((count, i) => { if (count >= COMBO_HELP_THRESHOLD && count < GRID_SIZE) targetRows.add(i); });
        colFullness.forEach((count, i) => { if (count >= COMBO_HELP_THRESHOLD && count < GRID_SIZE) targetCols.add(i); });

        const scoredPieces = PIECE_DEFINITIONS.map(pieceDef => {
            let maxScore = 0;
            let isPlayable = false;
            
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    if (canPlacePiece(pieceDef, x, y)) {
                        isPlayable = true;
                        let currentScore = 1;
                        
                        pieceDef.shape.forEach((row, py) => {
                            row.forEach((val, px) => {
                                if (val) {
                                    const boardY = y + py;
                                    const boardX = x + px;
                                    if (targetRows.has(boardY)) currentScore++;
                                    if (targetCols.has(boardX)) currentScore++;
                                }
                            });
                        });
                        if (currentScore > maxScore) maxScore = currentScore;
                    }
                }
            }
            return { ...pieceDef, score: isPlayable ? maxScore : -1 };
        }).filter(p => p.score > 0);

        let newPieces = [];
        if (scoredPieces.length < 3) {
            let randomPieces = [];
            let allPlayable = PIECE_DEFINITIONS.filter(p => isPiecePlayable(p));
            if (allPlayable.length === 0) {
                 currentPieces = [PIECE_DEFINITIONS[0], PIECE_DEFINITIONS[0], PIECE_DEFINITIONS[0]].map((p,i) => ({...p, id:i, used:true}));
                 return;
            }
            for (let i = 0; i < 3; i++) {
                randomPieces.push(allPlayable[Math.floor(Math.random() * allPlayable.length)]);
            }
            newPieces = randomPieces;
        } else {
            scoredPieces.sort((a, b) => b.score - a.score);
            const topTier = scoredPieces.slice(0, Math.min(scoredPieces.length, 12));
            
            for (let i = 0; i < 3; i++) {
                const totalWeight = topTier.reduce((sum, p) => sum + p.score, 0);
                let rand = Math.random() * totalWeight;
                let chosenPiece = topTier[topTier.length - 1];
                for (const piece of topTier) {
                    rand -= piece.score;
                    if (rand <= 0) {
                        chosenPiece = piece;
                        break;
                    }
                }
                newPieces.push(chosenPiece);
            }
        }
        
        currentPieces = newPieces.map((p, i) => ({ ...p, id: i, used: false }));
        pieceContainers.forEach(cont => cont.classList.remove('used'));

        if (!currentPieces.some(p => isPiecePlayable(p))) {
             console.warn("Smart generator created unplayable set. Retrying with random.");
             let safetyBreak = 0;
             do {
                currentPieces = [];
                for (let i=0; i<3; i++) {
                    const pieceDef = PIECE_DEFINITIONS[Math.floor(Math.random() * PIECE_DEFINITIONS.length)];
                    currentPieces.push({ ...pieceDef, id: i, used: false });
                }
                safetyBreak++;
             } while(!currentPieces.some(p => isPiecePlayable(p)) && safetyBreak < 100);
        }
    }

    // --- Game Actions ---
    function isPiecePlayable(piece, targetBoard = board) {
        for (let y = 0; y < GRID_SIZE; y++) {
            for (let x = 0; x < GRID_SIZE; x++) {
                if (canPlacePiece(piece, x, y, targetBoard)) {
                    return true;
                }
            }
        }
        return false;
    }
    
    function placePiece(piece, gridX, gridY) {
        if (!canPlacePiece(piece, gridX, gridY)) return false;
        
        sounds.place();
        let blocksInPiece = 0;
        piece.shape.forEach((row, y) => {
            row.forEach((value, x) => {
                if (value) { 
                    board[gridY + y][gridX + x] = piece.color; 
                    score++;
                    blocksInPiece++;
                }
            });
        });

        if (blocksInPiece >= 8) {
            score += 50;
        }
        
        piece.used = true;
        pieceContainers[piece.id].classList.add('used');
        updateScoreDisplay(); 
        
        const linesWereCleared = clearLines();

        // Check if round is over (all 3 pieces used)
        if (currentPieces.every(p => p.used)) { 
            // If no line was cleared this round, break the combo streak
            if (!clearedLineThisRound) {
                combo = 0;
                updateComboDisplay();
            }
            generateNewPieces(); // This also resets the clearedLineThisRound flag
            drawPiecesForSelection(); 
        }
        
        if (!linesWereCleared) {
            checkGameOver();
        }
        return true;
    }

    function canPlacePiece(piece, gridX, gridY, targetBoard = board) {
        for(let y = 0; y < piece.shape.length; y++) {
            for (let x = 0; x < piece.shape[y].length; x++) {
                if (piece.shape[y][x]) {
                    const boardY = gridY + y; const boardX = gridX + x;
                    if (boardY >= GRID_SIZE || boardX < 0 || boardX >= GRID_SIZE || targetBoard[boardY][boardX]) return false;
                }
            }
        }
        return true;
    }
    
    function clearLines() {
        let linesToClear = { rows: [], cols: [] };
        for(let i = 0; i < GRID_SIZE; i++) {
            if (board[i].every(cell => cell)) linesToClear.rows.push(i);
            if (board.every(row => row[i])) linesToClear.cols.push(i);
        }
        let linesClearedCount = linesToClear.rows.length + linesToClear.cols.length;
        
        if(linesClearedCount === 0) { 
            return false; // Don't reset combo here, wait until the round of 3 pieces is over
        }

        combo++;
        clearedLineThisRound = true; // Mark that a clear happened in this round
        const multiplier = Math.min(combo, 8); // Cap multiplier at 8x as per PDF
        score += linesClearedCount * 10 * multiplier;
        sounds.clear();
        updateComboDisplay();
        
        linesToClear.rows.forEach(y => {
            triggerLineClearFlash(y, 'row');
            for(let x=0; x < GRID_SIZE; x++) animateBlockClear(x,y);
        });
        linesToClear.cols.forEach(x => {
            triggerLineClearFlash(x, 'col');
            for(let y=0; y < GRID_SIZE; y++) if(!linesToClear.rows.includes(y)) animateBlockClear(x,y);
        });
        
        setTimeout(() => {
             linesToClear.rows.forEach(y => board[y].fill(null));
             linesToClear.cols.forEach(x => board.forEach(row => row[x] = null));
             updateScoreDisplay(); 
             checkGameOver();
        }, 200);

        return true;
    }
     
    function checkGameOver() {
        if (gameOver) return;
        for (const piece of currentPieces) {
            if (!piece.used && isPiecePlayable(piece)) return;
        }
        gameOver = true;
        sounds.gameOver();
        saveHighScore();
        finalScoreElement.textContent = score;
        gameOverModal.classList.add('visible');
    }

    // --- Drawing & Rendering ---
    
    function gameLoop() { draw(); requestAnimationFrame(gameLoop); }

    function draw() {
        mainCtx.clearRect(0, 0, mainCanvas.width, mainCanvas.height);
        drawGridLines();
        drawBoard();
        updateAndDrawClearingAnimation();
        if(isDragging) drawDraggedPiece();
    }

    function drawGridLines() {
        mainCtx.strokeStyle = 'rgba(0, 0, 0, 0.1)'; mainCtx.lineWidth = 1;
        for (let i = 1; i < GRID_SIZE; i++) {
            mainCtx.beginPath();
            mainCtx.moveTo(i * BLOCK_SIZE, 0); mainCtx.lineTo(i * BLOCK_SIZE, mainCanvas.height);
            mainCtx.moveTo(0, i * BLOCK_SIZE); mainCtx.lineTo(mainCanvas.width, i * BLOCK_SIZE);
            mainCtx.stroke();
        }
    }

    function drawBoard() {
        for(let y = 0; y < GRID_SIZE; y++) {
            for(let x = 0; x < GRID_SIZE; x++) {
                if(board[y][x] && board[y][x] !== 'clearing') {
                    drawBlock(mainCtx, x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, board[y][x]);
                }
            }
        }
    }
    
    function drawPiecesForSelection() {
        currentPieces.forEach((piece, i) => {
            const ctx = pieceContexts[i];
            const cont = pieceContainers[i];
            const size = Math.min(cont.clientWidth, cont.clientHeight);
            ctx.canvas.width = size; ctx.canvas.height = size;
            ctx.clearRect(0, 0, size, size);
            if (piece) {
                const bSize = Math.floor(size / 5);
                const w = piece.shape[0].length * bSize;
                const h = piece.shape.length * bSize;
                const startX = (size - w) / 2; const startY = (size - h) / 2;
                piece.shape.forEach((row, y) => {
                    row.forEach((value, x) => {
                        if (value) drawBlock(ctx, startX + x * bSize, startY + y * bSize, bSize, piece.color);
                    });
                });
            }
        });
    }

    function drawBlock(ctx, x, y, size, color) {
        const bevelSize = Math.max(1, size * 0.1);
        ctx.fillStyle = color.main; ctx.fillRect(x, y, size, size);
        ctx.fillStyle = color.light;
        ctx.beginPath();
        ctx.moveTo(x, y); ctx.lineTo(x + size, y); ctx.lineTo(x + size - bevelSize, y + bevelSize);
        ctx.lineTo(x + bevelSize, y + bevelSize); ctx.lineTo(x + bevelSize, y + size - bevelSize);
        ctx.lineTo(x, y + size); ctx.closePath(); ctx.fill();
        ctx.fillStyle = color.dark;
        ctx.beginPath();
        ctx.moveTo(x + size, y + size); ctx.lineTo(x, y + size); ctx.lineTo(x + bevelSize, y + size - bevelSize);
        ctx.lineTo(x + size - bevelSize, y + size - bevelSize); ctx.lineTo(x + size - bevelSize, y + bevelSize);
        ctx.lineTo(x + size, y); ctx.closePath(); ctx.fill();
        ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
        ctx.fillRect(x + bevelSize, y + bevelSize, size - bevelSize * 2, size - bevelSize * 2);
    }
    
    function drawDraggedPiece() {
        const mainRect = mainCanvas.getBoundingClientRect();
        const piecePixelWidth = draggedPiece.shape[0].length * BLOCK_SIZE;
        const piecePixelHeight = draggedPiece.shape.length * BLOCK_SIZE;
        let startX = pointerPos.x - mainRect.left - (piecePixelWidth / 2);
        let startY = pointerPos.y - mainRect.top - (piecePixelHeight / 2);

        startX = Math.max(-BLOCK_SIZE*0.5, Math.min(startX, mainCanvas.width - piecePixelWidth + BLOCK_SIZE*0.5));
        startY = Math.max(-BLOCK_SIZE*0.5, Math.min(startY, mainCanvas.height - piecePixelHeight + BLOCK_SIZE*0.5));
        
        const gridX = Math.round(startX / BLOCK_SIZE);
        const gridY = Math.round(startY / BLOCK_SIZE);
        
        const isValid = canPlacePiece(draggedPiece, gridX, gridY);

        draggedPiece.shape.forEach((row, y) => {
            row.forEach((value, x) => {
                if (value) {
                    mainCtx.globalAlpha = 0.6;
                    drawBlock(mainCtx, (gridX + x) * BLOCK_SIZE, (gridY + y) * BLOCK_SIZE, BLOCK_SIZE, isValid ? draggedPiece.color : COLORS.red);
                    mainCtx.globalAlpha = 1.0;
                }
            });
        });
    }

    // --- Event Handling ---
    function handlePointerStart(e) {
        if(gameOver) return; // Prevent interaction when game is over
        const target = e.target;
        if(target.classList.contains('piece-canvas')) {
            e.preventDefault();
            const cont = target.parentElement;
            const pieceIndex = parseInt(cont.id.split('-')[2]);
            if(currentPieces[pieceIndex] && !currentPieces[pieceIndex].used) {
                isDragging = true; draggedPiece = currentPieces[pieceIndex];
                pointerPos.x = e.clientX || e.touches[0].clientX; pointerPos.y = e.clientY || e.touches[0].clientY;
                document.body.style.cursor = 'grabbing'; cont.style.transform = 'scale(1.2)';
            }
        }
    }
    
    function handlePointerMove(e) {
        if (isDragging) { e.preventDefault(); pointerPos.x = e.clientX || e.touches[0].clientX; pointerPos.y = e.clientY || e.touches[0].clientY; }
    }
    
    function handlePointerEnd(e) {
        if(isDragging) {
            isDragging = false; document.body.style.cursor = 'default';
            pieceContainers[draggedPiece.id].style.transform = 'scale(1)';
            const mainRect = mainCanvas.getBoundingClientRect();
            if(pointerPos.x >= mainRect.left && pointerPos.x <= mainRect.right && pointerPos.y >= mainRect.top && pointerPos.y <= mainRect.bottom) {
                const piecePixelWidth = draggedPiece.shape[0].length * BLOCK_SIZE;
                const piecePixelHeight = draggedPiece.shape.length * BLOCK_SIZE;
                const startX = pointerPos.x - mainRect.left - (piecePixelWidth / 2);
                const startY = pointerPos.y - mainRect.top - (piecePixelHeight / 2);
                const gridX = Math.round(startX / BLOCK_SIZE);
                const gridY = Math.round(startY / BLOCK_SIZE);
                
                placePiece(draggedPiece, gridX, gridY);
            }
            draggedPiece = null;
        }
    }
    
    function toggleSettingsModal() {
        settingsModal.classList.toggle('visible');
    }

    // --- Animations ---
    function animateBlockClear(x, y) {
        if (board[y][x]) {
            clearingBlocks.push({ x, y, color: board[y][x], scale: 1 });
            board[y][x] = 'clearing';
        }
    }
    
    function updateAndDrawClearingAnimation() {
        if(clearingBlocks.length === 0) return;
        for (let i = clearingBlocks.length - 1; i >= 0; i--) {
            let block = clearingBlocks[i];
            block.scale -= 0.1;
            if (block.scale <= 0) {
                clearingBlocks.splice(i, 1);
            } else {
                mainCtx.save();
                mainCtx.translate(block.x * BLOCK_SIZE + BLOCK_SIZE / 2, block.y * BLOCK_SIZE + BLOCK_SIZE / 2);
                mainCtx.scale(block.scale, block.scale);
                drawBlock(mainCtx, -BLOCK_SIZE/2, -BLOCK_SIZE/2, BLOCK_SIZE, block.color);
                mainCtx.restore();
            }
        }
    }

    function triggerLineClearFlash(index, type) {
        const flash = document.createElement('div');
        flash.className = 'line-clear-flash';
        flash.style.left = type === 'row' ? '0px' : `${index * BLOCK_SIZE}px`;
        flash.style.top = type === 'row' ? `${index * BLOCK_SIZE}px` : '0px';
        flash.style.width = type === 'row' ? `${mainCanvas.width}px` : `${BLOCK_SIZE}px`;
        flash.style.height = type === 'row' ? `${BLOCK_SIZE}px` : `${mainCanvas.height}px`;
        flash.style.animation = 'flash-animation 0.3s ease-out';
        mainCanvas.parentElement.appendChild(flash);
        setTimeout(() => flash.remove(), 300);
    }
    
    // --- Listeners & Init ---
    window.addEventListener('resize', () => { setTimeout(drawPiecesForSelection, 100); });
    pieceContainers.forEach(c => {
        c.addEventListener('mousedown', handlePointerStart);
        c.addEventListener('touchstart', handlePointerStart, { passive: false });
    });
    document.addEventListener('mousemove', handlePointerMove);
    document.addEventListener('touchmove', handlePointerMove, { passive: false });
    document.addEventListener('mouseup', handlePointerEnd);
    document.addEventListener('touchend', handlePointerEnd);
    
    restartButton.addEventListener('click', resetGame);
    
    // Settings modal listeners
    settingsButton.addEventListener('click', toggleSettingsModal);
    closeSettingsButton.addEventListener('click', toggleSettingsModal);
    settingsModal.addEventListener('click', (e) => { // Close if clicking background
        if (e.target === settingsModal) {
            toggleSettingsModal();
        }
    });
    settingsRetryButton.addEventListener('click', () => {
        toggleSettingsModal();
        resetGame();
    });
    
    resetGame();
    gameLoop();
});
</script>

</body>
</html>
